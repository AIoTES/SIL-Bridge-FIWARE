/*
 * FIWARE-NGSI v2 Specification
 * FIWARE-NGSI v2 Specification
 *
 * OpenAPI spec version: 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.interiot.fiware.ngsiv2.client.api;

import org.interiot.fiware.ngsiv2.client.ApiCallback;
import org.interiot.fiware.ngsiv2.client.ApiClient;
import org.interiot.fiware.ngsiv2.client.ApiException;
import org.interiot.fiware.ngsiv2.client.ApiResponse;
import org.interiot.fiware.ngsiv2.client.Configuration;
import org.interiot.fiware.ngsiv2.client.Pair;
import org.interiot.fiware.ngsiv2.client.ProgressRequestBody;
import org.interiot.fiware.ngsiv2.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import org.interiot.fiware.ngsiv2.client.model.Registration;
import org.interiot.fiware.ngsiv2.client.model.Subscription;
import org.interiot.fiware.ngsiv2.client.model.Discoverrequest;
import org.interiot.fiware.ngsiv2.client.model.Entity;
import org.interiot.fiware.ngsiv2.client.model.Queryrequest;
import org.interiot.fiware.ngsiv2.client.model.Queryresponse;
import org.interiot.fiware.ngsiv2.client.model.Registerrequest;
import org.interiot.fiware.ngsiv2.client.model.Attributes;
import org.interiot.fiware.ngsiv2.client.model.Resources;
import org.interiot.fiware.ngsiv2.client.model.EntityType;
import org.interiot.fiware.ngsiv2.client.model.UpdateRequest;
import org.interiot.fiware.ngsiv2.client.model.Attribute;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AllApi {
	private ApiClient apiClient;

	public AllApi() {
		this(Configuration.getDefaultApiClient());
	}

	public AllApi(ApiClient apiClient) {
		this.apiClient = apiClient;
	}

	public ApiClient getApiClient() {
		return apiClient;
	}

	public void setApiClient(ApiClient apiClient) {
		this.apiClient = apiClient;
	}

	/* Build call for createANewContextProviderRegistration */
	private com.squareup.okhttp.Call createANewContextProviderRegistrationCall(Registration body,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException(
					"Missing the required parameter 'body' when calling createANewContextProviderRegistration(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/registrations".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Creates a new registration. This is typically used for associating
	 * context providers to certain data. The registration is represented by a
	 * JSON object as described at the beginning of this section. Response: *
	 * Successful operation uses 201 Created * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createANewContextProviderRegistration(Registration body) throws ApiException {
		createANewContextProviderRegistrationWithHttpInfo(body);
	}

	/**
	 * 
	 * Creates a new registration. This is typically used for associating
	 * context providers to certain data. The registration is represented by a
	 * JSON object as described at the beginning of this section. Response: *
	 * Successful operation uses 201 Created * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createANewContextProviderRegistrationWithHttpInfo(Registration body) throws ApiException {
		com.squareup.okhttp.Call call = createANewContextProviderRegistrationCall(body, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Creates a new registration. This is typically used for
	 * associating context providers to certain data. The registration is
	 * represented by a JSON object as described at the beginning of this
	 * section. Response: * Successful operation uses 201 Created * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createANewContextProviderRegistrationAsync(Registration body,
			final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createANewContextProviderRegistrationCall(body, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createANewSubscription */
	private com.squareup.okhttp.Call createANewSubscriptionCall(Subscription body,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling createANewSubscription(Async)");
		}		

		// create path and map variables
		String localVarPath = "/v2/subscriptions".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Creates a new subscription. The subscription is represented by a JSON
	 * object as described at the beginning of this section. Response: *
	 * Successful operation uses 201 Created * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createANewSubscription(Subscription body) throws ApiException {
		createANewSubscriptionWithHttpInfo(body);
	}

	/**
	 * 
	 * Creates a new subscription. The subscription is represented by a JSON
	 * object as described at the beginning of this section. Response: *
	 * Successful operation uses 201 Created * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createANewSubscriptionWithHttpInfo(Subscription body) throws ApiException {
		com.squareup.okhttp.Call call = createANewSubscriptionCall(body, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Creates a new subscription. The subscription is
	 * represented by a JSON object as described at the beginning of this
	 * section. Response: * Successful operation uses 201 Created * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createANewSubscriptionAsync(Subscription body, final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createANewSubscriptionCall(body, progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createDiscover */
	private com.squareup.okhttp.Call createDiscoverCall(Discoverrequest body, Double limit, Double offset,
			String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling createDiscover(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/op/discover/".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (limit != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
		if (offset != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The response payload is an Array that contains one object per matching
	 * registration. The registrations follow the JSON registration
	 * representation format (described in a section above). The payload may
	 * contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each entity is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the results of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * a &#x60;value&#x60; (whose type depends on the &#x60;type&#x60;
	 * property). The different available scopes are described elsewhere.
	 * Response code: * Successful operation uses 200 OK * Errors use a non-2xx
	 * and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of registrations to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of registrations. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @return List&lt;Registration&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<Registration> createDiscover(Discoverrequest body, Double limit, Double offset, String options)
			throws ApiException {
		ApiResponse<List<Registration>> resp = createDiscoverWithHttpInfo(body, limit, offset, options);
		return resp.getData();
	}

	/**
	 * 
	 * The response payload is an Array that contains one object per matching
	 * registration. The registrations follow the JSON registration
	 * representation format (described in a section above). The payload may
	 * contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each entity is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the results of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * a &#x60;value&#x60; (whose type depends on the &#x60;type&#x60;
	 * property). The different available scopes are described elsewhere.
	 * Response code: * Successful operation uses 200 OK * Errors use a non-2xx
	 * and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of registrations to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of registrations. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @return ApiResponse&lt;List&lt;Registration&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<Registration>> createDiscoverWithHttpInfo(Discoverrequest body, Double limit, Double offset,
			String options) throws ApiException {
		com.squareup.okhttp.Call call = createDiscoverCall(body, limit, offset, options, null, null);
		Type localVarReturnType = new TypeToken<List<Registration>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) The response payload is an Array that contains one
	 * object per matching registration. The registrations follow the JSON
	 * registration representation format (described in a section above). The
	 * payload may contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each entity is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the results of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * a &#x60;value&#x60; (whose type depends on the &#x60;type&#x60;
	 * property). The different available scopes are described elsewhere.
	 * Response code: * Successful operation uses 200 OK * Errors use a non-2xx
	 * and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of registrations to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of registrations. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createDiscoverAsync(Discoverrequest body, Double limit, Double offset,
			String options, final ApiCallback<List<Registration>> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createDiscoverCall(body, limit, offset, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<List<Registration>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for createEntity */
	private com.squareup.okhttp.Call createEntityCall(Entity body, String options,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling createEntity(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The payload is an object representing the entity to be created. The
	 * object follows the JSON entity representation format (described in a
	 * \&quot;JSON Entity Representation\&quot; section). Response: * Successful
	 * operation uses 201 Created. Reponse includes a &#x60;Location&#x60;
	 * header with the URL of the created entity. * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createEntity(Entity body, String options) throws ApiException {
		createEntityWithHttpInfo(body, options);
	}

	/**
	 * 
	 * The payload is an object representing the entity to be created. The
	 * object follows the JSON entity representation format (described in a
	 * \&quot;JSON Entity Representation\&quot; section). Response: * Successful
	 * operation uses 201 Created. Reponse includes a &#x60;Location&#x60;
	 * header with the URL of the created entity. * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createEntityWithHttpInfo(Entity body, String options) throws ApiException {
		com.squareup.okhttp.Call call = createEntityCall(body, options, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) The payload is an object representing the entity to be
	 * created. The object follows the JSON entity representation format
	 * (described in a \&quot;JSON Entity Representation\&quot; section).
	 * Response: * Successful operation uses 201 Created. Reponse includes a
	 * &#x60;Location&#x60; header with the URL of the created entity. * Errors
	 * use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createEntityAsync(Entity body, String options, final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createEntityCall(body, options, progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createNotifyContext */
	private com.squareup.okhttp.Call createNotifyContextCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/notifyContext".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (The payload of the v2 notifyContext should be described)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createNotifyContext() throws ApiException {
		createNotifyContextWithHttpInfo();
	}

	/**
	 * 
	 * (The payload of the v2 notifyContext should be described)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createNotifyContextWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createNotifyContextCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (The payload of the v2 notifyContext should be
	 * described)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createNotifyContextAsync(final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createNotifyContextCall(progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createNotifyContextAvailability */
	private com.squareup.okhttp.Call createNotifyContextAvailabilityCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/notifyContextAvailability".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (The payload of the v2 notifyContextAvailability should be described)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createNotifyContextAvailability() throws ApiException {
		createNotifyContextAvailabilityWithHttpInfo();
	}

	/**
	 * 
	 * (The payload of the v2 notifyContextAvailability should be described)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createNotifyContextAvailabilityWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createNotifyContextAvailabilityCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (The payload of the v2 notifyContextAvailability should
	 * be described)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createNotifyContextAvailabilityAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createNotifyContextAvailabilityCall(progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createQuery */
	private com.squareup.okhttp.Call createQueryCall(Queryrequest body, Double limit, Double offset, String orderBy,
			String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling createQuery(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/op/query".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (limit != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
		if (offset != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
		if (orderBy != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "orderBy", orderBy));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The response payload is an Array containing one object per matching
	 * entity, or an empty array &#x60;[]&#x60; if no entities are found. The
	 * entities follow the JSON entity representation format (described in the
	 * section \&quot;JSON Entity Representation\&quot;). The payload may
	 * contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each element is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the result of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * &#x60;value&#x60; (whose type depends on the &#x60;type&#x60; property).
	 * The different available scopes are described elsewhere. Response code: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of entities to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return List&lt;Queryresponse&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<Queryresponse> createQuery(Queryrequest body, Double limit, Double offset, String orderBy,
			String options) throws ApiException {
		ApiResponse<List<Queryresponse>> resp = createQueryWithHttpInfo(body, limit, offset, orderBy, options);
		return resp.getData();
	}

	/**
	 * 
	 * The response payload is an Array containing one object per matching
	 * entity, or an empty array &#x60;[]&#x60; if no entities are found. The
	 * entities follow the JSON entity representation format (described in the
	 * section \&quot;JSON Entity Representation\&quot;). The payload may
	 * contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each element is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the result of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * &#x60;value&#x60; (whose type depends on the &#x60;type&#x60; property).
	 * The different available scopes are described elsewhere. Response code: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of entities to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;List&lt;Queryresponse&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<Queryresponse>> createQueryWithHttpInfo(Queryrequest body, Double limit, Double offset,
			String orderBy, String options) throws ApiException {
		com.squareup.okhttp.Call call = createQueryCall(body, limit, offset, orderBy, options, null, null);
		Type localVarReturnType = new TypeToken<List<Queryresponse>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) The response payload is an Array containing one object
	 * per matching entity, or an empty array &#x60;[]&#x60; if no entities are
	 * found. The entities follow the JSON entity representation format
	 * (described in the section \&quot;JSON Entity Representation\&quot;). The
	 * payload may contain the following elements (all of them optional): +
	 * &#x60;entities&#x60;: a list of entites to search for. Each element is
	 * represented by a JSON object with the following elements: +
	 * &#x60;id&#x60; or &#x60;idPattern&#x60;: Id or pattern of the affected
	 * entities. Both cannot be used at the same time, but at least one of them
	 * must be present. + &#x60;type&#x60; or &#x60;typePattern&#x60;: Type or
	 * type pattern of the entities to search for. Both cannot be used at the
	 * same time. If omitted, it means \&quot;any entity type\&quot;. +
	 * &#x60;attributes&#x60;: a list of attribute names to search for. If
	 * omitted, it means \&quot;all attributes\&quot;. + &#x60;scopes&#x60;: a
	 * list of scopes to restrict the result of the query. Each scope is
	 * represented by a JSON object with a &#x60;type&#x60; (a JSON string) and
	 * &#x60;value&#x60; (whose type depends on the &#x60;type&#x60; property).
	 * The different available scopes are described elsewhere. Response code: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param body
	 *            (required)
	 * @param limit
	 *            Limit the number of entities to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createQueryAsync(Queryrequest body, Double limit, Double offset, String orderBy,
			String options, final ApiCallback<List<Queryresponse>> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createQueryCall(body, limit, offset, orderBy, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<List<Queryresponse>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for createRegister */
	private com.squareup.okhttp.Call createRegisterCall(Registerrequest body,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling createRegister(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/op/register".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This operation allows to create, update and/or delete several
	 * registrations in a single batch operation. The payload is an object with
	 * two properties: + &#x60;actionType&#x60;, to specify the kind of register
	 * action to do: either CREATE, UPDATE, or DELETE. +
	 * &#x60;registrations&#x60;, an array of registrations, each one specified
	 * using the JSON registration representation format (described above). In
	 * the case of CREATE operation, the registration &#x60;id&#x60; must not be
	 * included. Response: * Successful operation uses 200 OK. In addition, in
	 * the case of successful CREATE, a list of IDs is returned, each one
	 * corresponding to the ID of the element in the request payload and in that
	 * same order. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @return List&lt;String&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<String> createRegister(Registerrequest body) throws ApiException {
		ApiResponse<List<String>> resp = createRegisterWithHttpInfo(body);
		return resp.getData();
	}

	/**
	 * 
	 * This operation allows to create, update and/or delete several
	 * registrations in a single batch operation. The payload is an object with
	 * two properties: + &#x60;actionType&#x60;, to specify the kind of register
	 * action to do: either CREATE, UPDATE, or DELETE. +
	 * &#x60;registrations&#x60;, an array of registrations, each one specified
	 * using the JSON registration representation format (described above). In
	 * the case of CREATE operation, the registration &#x60;id&#x60; must not be
	 * included. Response: * Successful operation uses 200 OK. In addition, in
	 * the case of successful CREATE, a list of IDs is returned, each one
	 * corresponding to the ID of the element in the request payload and in that
	 * same order. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @return ApiResponse&lt;List&lt;String&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<String>> createRegisterWithHttpInfo(Registerrequest body) throws ApiException {
		com.squareup.okhttp.Call call = createRegisterCall(body, null, null);
		Type localVarReturnType = new TypeToken<List<String>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) This operation allows to create, update and/or delete
	 * several registrations in a single batch operation. The payload is an
	 * object with two properties: + &#x60;actionType&#x60;, to specify the kind
	 * of register action to do: either CREATE, UPDATE, or DELETE. +
	 * &#x60;registrations&#x60;, an array of registrations, each one specified
	 * using the JSON registration representation format (described above). In
	 * the case of CREATE operation, the registration &#x60;id&#x60; must not be
	 * included. Response: * Successful operation uses 200 OK. In addition, in
	 * the case of successful CREATE, a list of IDs is returned, each one
	 * corresponding to the ID of the element in the request payload and in that
	 * same order. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createRegisterAsync(Registerrequest body, final ApiCallback<List<String>> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createRegisterCall(body, progressListener, progressRequestListener);
		Type localVarReturnType = new TypeToken<List<String>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for createSubscribeContext */
	private com.squareup.okhttp.Call createSubscribeContextCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/subscribeContext".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful POST /v2/subscriptions
	 * operation)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createSubscribeContext() throws ApiException {
		createSubscribeContextWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful POST /v2/subscriptions
	 * operation)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createSubscribeContextWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createSubscribeContextCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed, as it is covered by the RESTful POST
	 * /v2/subscriptions operation)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createSubscribeContextAsync(final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createSubscribeContextCall(progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createSubscribeContextAvailability */
	private com.squareup.okhttp.Call createSubscribeContextAvailabilityCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/subscribeContextAvailability".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createSubscribeContextAvailability() throws ApiException {
		createSubscribeContextAvailabilityWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createSubscribeContextAvailabilityWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createSubscribeContextAvailabilityCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed as POJ RPC, but we need to define a RESTful
	 * operation for this, analogous to the NGSI10 one)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createSubscribeContextAvailabilityAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createSubscribeContextAvailabilityCall(progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createUnsubscribeContext */
	private com.squareup.okhttp.Call createUnsubscribeContextCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/unsubscribeContext".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful DELETE /v2/subscriptions
	 * operation)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createUnsubscribeContext() throws ApiException {
		createUnsubscribeContextWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful DELETE /v2/subscriptions
	 * operation)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createUnsubscribeContextWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createUnsubscribeContextCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed, as it is covered by the RESTful DELETE
	 * /v2/subscriptions operation)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createUnsubscribeContextAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createUnsubscribeContextCall(progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for createUnsubscribeContextAvailability */
	private com.squareup.okhttp.Call createUnsubscribeContextAvailabilityCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/unsubscribeContextAvailability".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void createUnsubscribeContextAvailability() throws ApiException {
		createUnsubscribeContextAvailabilityWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> createUnsubscribeContextAvailabilityWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = createUnsubscribeContextAvailabilityCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed as POJ RPC, but we need to define a RESTful
	 * operation for this, analogous to the NGSI10 one)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call createUnsubscribeContextAvailabilityAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = createUnsubscribeContextAvailabilityCall(progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for deleteContextProviderRegistration */
	private com.squareup.okhttp.Call deleteContextProviderRegistrationCall(String registrationId,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'registrationId' is set
		if (registrationId == null) {
			throw new ApiException(
					"Missing the required parameter 'registrationId' when calling deleteContextProviderRegistration(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/registrations/{registrationId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "registrationId" + "\\}", apiClient.escapeString(registrationId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Cancels registration. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void deleteContextProviderRegistration(String registrationId) throws ApiException {
		deleteContextProviderRegistrationWithHttpInfo(registrationId);
	}

	/**
	 * 
	 * Cancels registration. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> deleteContextProviderRegistrationWithHttpInfo(String registrationId) throws ApiException {
		com.squareup.okhttp.Call call = deleteContextProviderRegistrationCall(registrationId, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Cancels registration. Response: * Successful operation
	 * uses 204 No Content * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call deleteContextProviderRegistrationAsync(String registrationId,
			final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = deleteContextProviderRegistrationCall(registrationId, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for deleteSubscription */
	private com.squareup.okhttp.Call deleteSubscriptionCall(String subscriptionId,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'subscriptionId' is set
		if (subscriptionId == null) {
			throw new ApiException(
					"Missing the required parameter 'subscriptionId' when calling deleteSubscription(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/subscriptions/{subscriptionId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "subscriptionId" + "\\}", apiClient.escapeString(subscriptionId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Cancels subscription. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void deleteSubscription(String subscriptionId) throws ApiException {
		deleteSubscriptionWithHttpInfo(subscriptionId);
	}

	/**
	 * 
	 * Cancels subscription. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> deleteSubscriptionWithHttpInfo(String subscriptionId) throws ApiException {
		com.squareup.okhttp.Call call = deleteSubscriptionCall(subscriptionId, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Cancels subscription. Response: * Successful operation
	 * uses 204 No Content * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call deleteSubscriptionAsync(String subscriptionId, final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = deleteSubscriptionCall(subscriptionId, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for getAttributeData */
	private com.squareup.okhttp.Call getAttributeDataCall(String entityId, String attrName, String type,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException("Missing the required parameter 'entityId' when calling getAttributeData(Async)");
		}

		// verify the required parameter 'attrName' is set
		if (attrName == null) {
			throw new ApiException("Missing the required parameter 'attrName' when calling getAttributeData(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs/{attrName}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()))
				.replaceAll("\\{" + "attrName" + "\\}", apiClient.escapeString(attrName.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Returns a JSON object with the attribute data of the attribute. The
	 * object follows the JSON representation for attributes (described in
	 * \&quot;JSON Attribute Representation\&quot; section). Response: *
	 * Successful operation uses 20O OK. * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param entityId
	 *            Id of the entity (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @return Attributes
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Attributes getAttributeData(String entityId, String attrName, String type) throws ApiException {
		ApiResponse<Attributes> resp = getAttributeDataWithHttpInfo(entityId, attrName, type);
		return resp.getData();
	}

	/**
	 * 
	 * Returns a JSON object with the attribute data of the attribute. The
	 * object follows the JSON representation for attributes (described in
	 * \&quot;JSON Attribute Representation\&quot; section). Response: *
	 * Successful operation uses 20O OK. * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param entityId
	 *            Id of the entity (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @return ApiResponse&lt;Attributes&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Attributes> getAttributeDataWithHttpInfo(String entityId, String attrName, String type)
			throws ApiException {
		com.squareup.okhttp.Call call = getAttributeDataCall(entityId, attrName, type, null, null);
		Type localVarReturnType = new TypeToken<Attributes>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) Returns a JSON object with the attribute data of the
	 * attribute. The object follows the JSON representation for attributes
	 * (described in \&quot;JSON Attribute Representation\&quot; section).
	 * Response: * Successful operation uses 20O OK. * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call getAttributeDataAsync(String entityId, String attrName, String type,
			final ApiCallback<Attributes> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = getAttributeDataCall(entityId, attrName, type, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<Attributes>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for getAttributeValue */
	private com.squareup.okhttp.Call getAttributeValueCall(String entityId, String attrName, String type,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException("Missing the required parameter 'entityId' when calling getAttributeValue(Async)");
		}

		// verify the required parameter 'attrName' is set
		if (attrName == null) {
			throw new ApiException("Missing the required parameter 'attrName' when calling getAttributeValue(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs/{attrName}/value".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()))
				.replaceAll("\\{" + "attrName" + "\\}", apiClient.escapeString(attrName.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This operation returns the &#x60;value&#x60; property with the value of
	 * the attribute. * If attribute value is JSON Array or Object: * If
	 * &#x60;Accept&#x60; header can be expanded to &#x60;application/json&#x60;
	 * or &#x60;text/plain&#x60; return the value as a JSON with a response type
	 * of application/json or text/plain (whichever is the first in
	 * &#x60;Accept&#x60; header or &#x60;application/json&#x60; in the case of
	 * &#x60;Accept: *_/_*&#x60;). * Else return a HTTP error \&quot;406 Not
	 * Acceptable: accepted MIME types: application/json, text/plain\&quot; * If
	 * attribute value is a string, number, null or boolean: * If
	 * &#x60;Accept&#x60; header can be expanded to text/plain return the value
	 * as text. In case of a string, citation marks are used at the begining and
	 * end. * Else return a HTTP error \&quot;406 Not Acceptable: accepted MIME
	 * types: text/plain\&quot; Response: * Successful operation uses 20O OK. *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void getAttributeValue(String entityId, String attrName, String type) throws ApiException {
		getAttributeValueWithHttpInfo(entityId, attrName, type);
	}

	/**
	 * 
	 * This operation returns the &#x60;value&#x60; property with the value of
	 * the attribute. * If attribute value is JSON Array or Object: * If
	 * &#x60;Accept&#x60; header can be expanded to &#x60;application/json&#x60;
	 * or &#x60;text/plain&#x60; return the value as a JSON with a response type
	 * of application/json or text/plain (whichever is the first in
	 * &#x60;Accept&#x60; header or &#x60;application/json&#x60; in the case of
	 * &#x60;Accept: *_/_*&#x60;). * Else return a HTTP error \&quot;406 Not
	 * Acceptable: accepted MIME types: application/json, text/plain\&quot; * If
	 * attribute value is a string, number, null or boolean: * If
	 * &#x60;Accept&#x60; header can be expanded to text/plain return the value
	 * as text. In case of a string, citation marks are used at the begining and
	 * end. * Else return a HTTP error \&quot;406 Not Acceptable: accepted MIME
	 * types: text/plain\&quot; Response: * Successful operation uses 20O OK. *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> getAttributeValueWithHttpInfo(String entityId, String attrName, String type)
			throws ApiException {
		com.squareup.okhttp.Call call = getAttributeValueCall(entityId, attrName, type, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) This operation returns the &#x60;value&#x60; property
	 * with the value of the attribute. * If attribute value is JSON Array or
	 * Object: * If &#x60;Accept&#x60; header can be expanded to
	 * &#x60;application/json&#x60; or &#x60;text/plain&#x60; return the value
	 * as a JSON with a response type of application/json or text/plain
	 * (whichever is the first in &#x60;Accept&#x60; header or
	 * &#x60;application/json&#x60; in the case of &#x60;Accept: *_/_*&#x60;). *
	 * Else return a HTTP error \&quot;406 Not Acceptable: accepted MIME types:
	 * application/json, text/plain\&quot; * If attribute value is a string,
	 * number, null or boolean: * If &#x60;Accept&#x60; header can be expanded
	 * to text/plain return the value as text. In case of a string, citation
	 * marks are used at the begining and end. * Else return a HTTP error
	 * \&quot;406 Not Acceptable: accepted MIME types: text/plain\&quot;
	 * Response: * Successful operation uses 20O OK. * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question (required)
	 * @param attrName
	 *            Name of the attribute to be retrieved. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call getAttributeValueAsync(String entityId, String attrName, String type,
			final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = getAttributeValueCall(entityId, attrName, type, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for listEntities */
	private com.squareup.okhttp.Call listEntitiesCall(String id, String type, String idPattern, String typePattern,
			String q, String mq, String georel, String geometry, String coords, Double limit, Double offset,
			String attrs, String orderBy, String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/entities".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (id != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "id", id));
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
		if (idPattern != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "idPattern", idPattern));
		if (typePattern != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "typePattern", typePattern));
		if (q != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "q", q));
		if (mq != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "mq", mq));
		if (georel != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "georel", georel));
		if (geometry != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "geometry", geometry));
		if (coords != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "coords", coords));
		if (limit != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
		if (offset != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
		if (attrs != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "attrs", attrs));
		if (orderBy != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "orderBy", orderBy));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Retrieves a list of entities that match different criteria by id, type,
	 * pattern matching (either id or type) and/or those which match a query or
	 * geographical query. A given entity has to match all the criteria to be
	 * retrieved (i.e., the criteria is combined in a logical AND way). Note
	 * that pattern matching query parameters are incompatible (i.e. mutually
	 * exclusive) with their corresponding exact matching parameters, i.e.
	 * &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60;
	 * with &#x60;type&#x60;. The response payload is an array containing one
	 * object per matching entity. Each entity follows the JSON entity
	 * representation format (described in \&quot;JSON Entity
	 * Representation\&quot; section). Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param id
	 *            A comma-separated list of elements. Retrieve entities whose ID
	 *            matches one of the elements in the list. Incompatible with
	 *            idPattern. (optional)
	 * @param type
	 *            comma-separated list of elements. Retrieve entities whose type
	 *            matches one of the elements in the list. Incompatible with
	 *            &#x60;typePattern&#x60;. (optional)
	 * @param idPattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose ID matches the regular expression. Incompatible with id.
	 *            (optional)
	 * @param typePattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose type matches the regular expression. Incompatible with
	 *            &#x60;type&#x60;. (optional)
	 * @param q
	 *            A query expression, composed of a list of statements separated
	 *            by &#x60;;&#x60;, i.e., q&#x3D;statement;statements;statement.
	 *            See [Simple Query Language
	 *            specification](#simple_query_language). (optional)
	 * @param mq
	 *            A query expression for attribute metadata, composed of a list
	 *            of statements separated by &#x60;;&#x60;, i.e.,
	 *            mq&#x3D;statement1;statement2;statement3. See [Simple Query
	 *            Language specification](#simple_query_language). (optional)
	 * @param georel
	 *            Spatial relationship between matching entities and a reference
	 *            shape. See [Geographical Queries](#geographical_queries).
	 *            (optional)
	 * @param geometry
	 *            Geografical area to which the query is restricted. See
	 *            [Geographical Queries](#geographical_queries). (optional)
	 * @param coords
	 *            List of latitude-longitude pairs of coordinates separated by
	 *            &#39;;&#39;. See [Geographical
	 *            Queries](#geographical_queries). (optional)
	 * @param limit
	 *            Limits the number of entities to be retrieved (optional)
	 * @param offset
	 *            Establishes the offset from where entities are retrieved
	 *            (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order.
	 *            (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return List&lt;Entity&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<Entity> listEntities(String id, String type, String idPattern, String typePattern, String q, String mq,
			String georel, String geometry, String coords, Double limit, Double offset, String attrs, String orderBy,
			String options) throws ApiException {
		ApiResponse<List<Entity>> resp = listEntitiesWithHttpInfo(id, type, idPattern, typePattern, q, mq, georel,
				geometry, coords, limit, offset, attrs, orderBy, options);
		return resp.getData();
	}

	/**
	 * 
	 * Retrieves a list of entities that match different criteria by id, type,
	 * pattern matching (either id or type) and/or those which match a query or
	 * geographical query. A given entity has to match all the criteria to be
	 * retrieved (i.e., the criteria is combined in a logical AND way). Note
	 * that pattern matching query parameters are incompatible (i.e. mutually
	 * exclusive) with their corresponding exact matching parameters, i.e.
	 * &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60;
	 * with &#x60;type&#x60;. The response payload is an array containing one
	 * object per matching entity. Each entity follows the JSON entity
	 * representation format (described in \&quot;JSON Entity
	 * Representation\&quot; section). Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param id
	 *            A comma-separated list of elements. Retrieve entities whose ID
	 *            matches one of the elements in the list. Incompatible with
	 *            idPattern. (optional)
	 * @param type
	 *            comma-separated list of elements. Retrieve entities whose type
	 *            matches one of the elements in the list. Incompatible with
	 *            &#x60;typePattern&#x60;. (optional)
	 * @param idPattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose ID matches the regular expression. Incompatible with id.
	 *            (optional)
	 * @param typePattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose type matches the regular expression. Incompatible with
	 *            &#x60;type&#x60;. (optional)
	 * @param q
	 *            A query expression, composed of a list of statements separated
	 *            by &#x60;;&#x60;, i.e., q&#x3D;statement;statements;statement.
	 *            See [Simple Query Language
	 *            specification](#simple_query_language). (optional)
	 * @param mq
	 *            A query expression for attribute metadata, composed of a list
	 *            of statements separated by &#x60;;&#x60;, i.e.,
	 *            mq&#x3D;statement1;statement2;statement3. See [Simple Query
	 *            Language specification](#simple_query_language). (optional)
	 * @param georel
	 *            Spatial relationship between matching entities and a reference
	 *            shape. See [Geographical Queries](#geographical_queries).
	 *            (optional)
	 * @param geometry
	 *            Geografical area to which the query is restricted. See
	 *            [Geographical Queries](#geographical_queries). (optional)
	 * @param coords
	 *            List of latitude-longitude pairs of coordinates separated by
	 *            &#39;;&#39;. See [Geographical
	 *            Queries](#geographical_queries). (optional)
	 * @param limit
	 *            Limits the number of entities to be retrieved (optional)
	 * @param offset
	 *            Establishes the offset from where entities are retrieved
	 *            (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order.
	 *            (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;List&lt;Entity&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<Entity>> listEntitiesWithHttpInfo(String id, String type, String idPattern,
			String typePattern, String q, String mq, String georel, String geometry, String coords, Double limit,
			Double offset, String attrs, String orderBy, String options) throws ApiException {
		com.squareup.okhttp.Call call = listEntitiesCall(id, type, idPattern, typePattern, q, mq, georel, geometry,
				coords, limit, offset, attrs, orderBy, options, null, null);
		Type localVarReturnType = new TypeToken<List<Entity>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) Retrieves a list of entities that match different
	 * criteria by id, type, pattern matching (either id or type) and/or those
	 * which match a query or geographical query. A given entity has to match
	 * all the criteria to be retrieved (i.e., the criteria is combined in a
	 * logical AND way). Note that pattern matching query parameters are
	 * incompatible (i.e. mutually exclusive) with their corresponding exact
	 * matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and
	 * &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an
	 * array containing one object per matching entity. Each entity follows the
	 * JSON entity representation format (described in \&quot;JSON Entity
	 * Representation\&quot; section). Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param id
	 *            A comma-separated list of elements. Retrieve entities whose ID
	 *            matches one of the elements in the list. Incompatible with
	 *            idPattern. (optional)
	 * @param type
	 *            comma-separated list of elements. Retrieve entities whose type
	 *            matches one of the elements in the list. Incompatible with
	 *            &#x60;typePattern&#x60;. (optional)
	 * @param idPattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose ID matches the regular expression. Incompatible with id.
	 *            (optional)
	 * @param typePattern
	 *            A correctly formated regular expression. Retrieve entities
	 *            whose type matches the regular expression. Incompatible with
	 *            &#x60;type&#x60;. (optional)
	 * @param q
	 *            A query expression, composed of a list of statements separated
	 *            by &#x60;;&#x60;, i.e., q&#x3D;statement;statements;statement.
	 *            See [Simple Query Language
	 *            specification](#simple_query_language). (optional)
	 * @param mq
	 *            A query expression for attribute metadata, composed of a list
	 *            of statements separated by &#x60;;&#x60;, i.e.,
	 *            mq&#x3D;statement1;statement2;statement3. See [Simple Query
	 *            Language specification](#simple_query_language). (optional)
	 * @param georel
	 *            Spatial relationship between matching entities and a reference
	 *            shape. See [Geographical Queries](#geographical_queries).
	 *            (optional)
	 * @param geometry
	 *            Geografical area to which the query is restricted. See
	 *            [Geographical Queries](#geographical_queries). (optional)
	 * @param coords
	 *            List of latitude-longitude pairs of coordinates separated by
	 *            &#39;;&#39;. See [Geographical
	 *            Queries](#geographical_queries). (optional)
	 * @param limit
	 *            Limits the number of entities to be retrieved (optional)
	 * @param offset
	 *            Establishes the offset from where entities are retrieved
	 *            (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order.
	 *            (optional)
	 * @param orderBy
	 *            Criteria for ordering results. See \&quot;Ordering
	 *            Results\&quot; section for details. (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call listEntitiesAsync(String id, String type, String idPattern, String typePattern,
			String q, String mq, String georel, String geometry, String coords, Double limit, Double offset,
			String attrs, String orderBy, String options, final ApiCallback<List<Entity>> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = listEntitiesCall(id, type, idPattern, typePattern, q, mq, georel, geometry,
				coords, limit, offset, attrs, orderBy, options, progressListener, progressRequestListener);
		Type localVarReturnType = new TypeToken<List<Entity>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for removeASingleAttribute */
	private com.squareup.okhttp.Call removeASingleAttributeCall(String entityId, String attrName, String type,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException(
					"Missing the required parameter 'entityId' when calling removeASingleAttribute(Async)");
		}

		// verify the required parameter 'attrName' is set
		if (attrName == null) {
			throw new ApiException(
					"Missing the required parameter 'attrName' when calling removeASingleAttribute(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs/{attrName}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()))
				.replaceAll("\\{" + "attrName" + "\\}", apiClient.escapeString(attrName.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Removes an entity attribute. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity. (required)
	 * @param attrName
	 *            Attribute name. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void removeASingleAttribute(String entityId, String attrName, String type) throws ApiException {
		removeASingleAttributeWithHttpInfo(entityId, attrName, type);
	}

	/**
	 * 
	 * Removes an entity attribute. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity. (required)
	 * @param attrName
	 *            Attribute name. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> removeASingleAttributeWithHttpInfo(String entityId, String attrName, String type)
			throws ApiException {
		com.squareup.okhttp.Call call = removeASingleAttributeCall(entityId, attrName, type, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Removes an entity attribute. Response: * Successful
	 * operation uses 204 No Content * Errors use a non-2xx and (optionally) an
	 * error payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param entityId
	 *            Id of the entity. (required)
	 * @param attrName
	 *            Attribute name. (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call removeASingleAttributeAsync(String entityId, String attrName, String type,
			final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = removeASingleAttributeCall(entityId, attrName, type, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for removeEntity */
	private com.squareup.okhttp.Call removeEntityCall(String entityId, String type,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException("Missing the required parameter 'entityId' when calling removeEntity(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Delete the entity. Response: * Successful operation uses 204 No Content *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be deleted (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void removeEntity(String entityId, String type) throws ApiException {
		removeEntityWithHttpInfo(entityId, type);
	}

	/**
	 * 
	 * Delete the entity. Response: * Successful operation uses 204 No Content *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be deleted (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> removeEntityWithHttpInfo(String entityId, String type) throws ApiException {
		com.squareup.okhttp.Call call = removeEntityCall(entityId, type, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) Delete the entity. Response: * Successful operation uses
	 * 204 No Content * Errors use a non-2xx and (optionally) an error payload.
	 * See subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be deleted (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call removeEntityAsync(String entityId, String type, final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = removeEntityCall(entityId, type, progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for retrieveAPIResources */
	private com.squareup.okhttp.Call retrieveAPIResourcesCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = {

		};
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This resource does not have any attributes. Instead it offers the initial
	 * API affordances in the form of the links in the JSON body. It is
	 * recommended to follow the “url” link values,
	 * [Link](https://tools.ietf.org/html/rfc5988) or Location headers where
	 * applicable to retrieve resources. Instead of constructing your own URLs,
	 * to keep your client decoupled from implementation details.
	 * 
	 * @return Resources
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Resources retrieveAPIResources() throws ApiException {
		ApiResponse<Resources> resp = retrieveAPIResourcesWithHttpInfo();
		return resp.getData();
	}

	/**
	 * 
	 * This resource does not have any attributes. Instead it offers the initial
	 * API affordances in the form of the links in the JSON body. It is
	 * recommended to follow the “url” link values,
	 * [Link](https://tools.ietf.org/html/rfc5988) or Location headers where
	 * applicable to retrieve resources. Instead of constructing your own URLs,
	 * to keep your client decoupled from implementation details.
	 * 
	 * @return ApiResponse&lt;Resources&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Resources> retrieveAPIResourcesWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = retrieveAPIResourcesCall(null, null);
		Type localVarReturnType = new TypeToken<Resources>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) This resource does not have any attributes. Instead it
	 * offers the initial API affordances in the form of the links in the JSON
	 * body. It is recommended to follow the “url” link values,
	 * [Link](https://tools.ietf.org/html/rfc5988) or Location headers where
	 * applicable to retrieve resources. Instead of constructing your own URLs,
	 * to keep your client decoupled from implementation details.
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveAPIResourcesAsync(final ApiCallback<Resources> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveAPIResourcesCall(progressListener, progressRequestListener);
		Type localVarReturnType = new TypeToken<Resources>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveContextProviderRegistration */
	private com.squareup.okhttp.Call retrieveContextProviderRegistrationCall(String registrationId,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'registrationId' is set
		if (registrationId == null) {
			throw new ApiException(
					"Missing the required parameter 'registrationId' when calling retrieveContextProviderRegistration(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/registrations/{registrationId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "registrationId" + "\\}", apiClient.escapeString(registrationId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The response is the registration represented by a JSON object as
	 * described at the beginning of this section. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @return Registration
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Registration retrieveContextProviderRegistration(String registrationId) throws ApiException {
		ApiResponse<Registration> resp = retrieveContextProviderRegistrationWithHttpInfo(registrationId);
		return resp.getData();
	}

	/**
	 * 
	 * The response is the registration represented by a JSON object as
	 * described at the beginning of this section. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @return ApiResponse&lt;Registration&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Registration> retrieveContextProviderRegistrationWithHttpInfo(String registrationId)
			throws ApiException {
		com.squareup.okhttp.Call call = retrieveContextProviderRegistrationCall(registrationId, null, null);
		Type localVarReturnType = new TypeToken<Registration>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) The response is the registration represented by a JSON
	 * object as described at the beginning of this section. Response: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param registrationId
	 *            registration Id. (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveContextProviderRegistrationAsync(String registrationId,
			final ApiCallback<Registration> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveContextProviderRegistrationCall(registrationId, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<Registration>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveEntity */
	private com.squareup.okhttp.Call retrieveEntityCall(String entityId, String type, String attrs, String options,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException("Missing the required parameter 'entityId' when calling retrieveEntity(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
		if (attrs != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "attrs", attrs));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The response is an object representing the entity identified by the ID.
	 * The object follows the JSON entity representation format (described in
	 * \&quot;JSON Entity Representation\&quot; section). This operation must
	 * return one entity element only, but there may be more than one entity
	 * with the same ID (e.g. entities with same ID but different types). In
	 * such case, an error message is returned, with the HTTP status code set to
	 * 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data must be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return Entity
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Entity retrieveEntity(String entityId, String type, String attrs, String options) throws ApiException {
		ApiResponse<Entity> resp = retrieveEntityWithHttpInfo(entityId, type, attrs, options);
		return resp.getData();
	}

	/**
	 * 
	 * The response is an object representing the entity identified by the ID.
	 * The object follows the JSON entity representation format (described in
	 * \&quot;JSON Entity Representation\&quot; section). This operation must
	 * return one entity element only, but there may be more than one entity
	 * with the same ID (e.g. entities with same ID but different types). In
	 * such case, an error message is returned, with the HTTP status code set to
	 * 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data must be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;Entity&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Entity> retrieveEntityWithHttpInfo(String entityId, String type, String attrs, String options)
			throws ApiException {
		com.squareup.okhttp.Call call = retrieveEntityCall(entityId, type, attrs, options, null, null);
		Type localVarReturnType = new TypeToken<Entity>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) The response is an object representing the entity
	 * identified by the ID. The object follows the JSON entity representation
	 * format (described in \&quot;JSON Entity Representation\&quot; section).
	 * This operation must return one entity element only, but there may be more
	 * than one entity with the same ID (e.g. entities with same ID but
	 * different types). In such case, an error message is returned, with the
	 * HTTP status code set to 409 Conflict. Response: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data must be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveEntityAsync(String entityId, String type, String attrs, String options,
			final ApiCallback<Entity> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveEntityCall(entityId, type, attrs, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<Entity>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveEntityAttributes */
	private com.squareup.okhttp.Call retrieveEntityAttributesCall(String entityId, String type, String attrs,
			String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException(
					"Missing the required parameter 'entityId' when calling retrieveEntityAttributes(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
		if (attrs != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "attrs", attrs));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This request is similar to retreiving the whole entity, however this one
	 * omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the
	 * general request of getting an entire entity, this operation must return
	 * only one entity element. If more than one entity with the same ID is
	 * found (e.g. entities with same ID but different type), an error message
	 * is returned, with the HTTP status code set to 409 Conflict. Response: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return Attributes
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Attributes retrieveEntityAttributes(String entityId, String type, String attrs, String options)
			throws ApiException {
		ApiResponse<Attributes> resp = retrieveEntityAttributesWithHttpInfo(entityId, type, attrs, options);
		return resp.getData();
	}

	/**
	 * 
	 * This request is similar to retreiving the whole entity, however this one
	 * omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the
	 * general request of getting an entire entity, this operation must return
	 * only one entity element. If more than one entity with the same ID is
	 * found (e.g. entities with same ID but different type), an error message
	 * is returned, with the HTTP status code set to 409 Conflict. Response: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;Attributes&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Attributes> retrieveEntityAttributesWithHttpInfo(String entityId, String type, String attrs,
			String options) throws ApiException {
		com.squareup.okhttp.Call call = retrieveEntityAttributesCall(entityId, type, attrs, options, null, null);
		Type localVarReturnType = new TypeToken<Attributes>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) This request is similar to retreiving the whole entity,
	 * however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields.
	 * Just like the general request of getting an entire entity, this operation
	 * must return only one entity element. If more than one entity with the
	 * same ID is found (e.g. entities with same ID but different type), an
	 * error message is returned, with the HTTP status code set to 409 Conflict.
	 * Response: * Successful operation uses 200 OK * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to be retrieved (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param attrs
	 *            Comma-separated list of attribute names whose data are to be
	 *            included in the response. The attributes are retrieved in the
	 *            order specified by this parameter. If this parameter is not
	 *            included, the attributes are retrieved in arbitrary order, and
	 *            all the attributes of the entity are included in the response.
	 *            (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveEntityAttributesAsync(String entityId, String type, String attrs,
			String options, final ApiCallback<Attributes> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveEntityAttributesCall(entityId, type, attrs, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<Attributes>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveEntityType */
	private com.squareup.okhttp.Call retrieveEntityTypeCall(String entityType,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'entityType' is set
		if (entityType == null) {
			throw new ApiException(
					"Missing the required parameter 'entityType' when calling retrieveEntityType(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/types/{entityType}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityType" + "\\}", apiClient.escapeString(entityType.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This operation returns a JSON object with information about the type: *
	 * &#x60;attrs&#x60; : the set of attribute names along with all the
	 * entities of such type, represented in a JSON object whose keys are the
	 * attribute names and whose values contain information of such attributes
	 * (in particular a list of the types used by attributes with that name
	 * along with all the entities). * &#x60;count&#x60; : the number of
	 * entities belonging to that type. Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityType
	 *            Entity Type (required)
	 * @return EntityType
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public EntityType retrieveEntityType(String entityType) throws ApiException {
		ApiResponse<EntityType> resp = retrieveEntityTypeWithHttpInfo(entityType);
		return resp.getData();
	}

	/**
	 * 
	 * This operation returns a JSON object with information about the type: *
	 * &#x60;attrs&#x60; : the set of attribute names along with all the
	 * entities of such type, represented in a JSON object whose keys are the
	 * attribute names and whose values contain information of such attributes
	 * (in particular a list of the types used by attributes with that name
	 * along with all the entities). * &#x60;count&#x60; : the number of
	 * entities belonging to that type. Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityType
	 *            Entity Type (required)
	 * @return ApiResponse&lt;EntityType&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<EntityType> retrieveEntityTypeWithHttpInfo(String entityType) throws ApiException {
		com.squareup.okhttp.Call call = retrieveEntityTypeCall(entityType, null, null);
		Type localVarReturnType = new TypeToken<EntityType>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) This operation returns a JSON object with information
	 * about the type: * &#x60;attrs&#x60; : the set of attribute names along
	 * with all the entities of such type, represented in a JSON object whose
	 * keys are the attribute names and whose values contain information of such
	 * attributes (in particular a list of the types used by attributes with
	 * that name along with all the entities). * &#x60;count&#x60; : the number
	 * of entities belonging to that type. Response code: * Successful operation
	 * uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityType
	 *            Entity Type (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveEntityTypeAsync(String entityType, final ApiCallback<EntityType> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveEntityTypeCall(entityType, progressListener, progressRequestListener);
		Type localVarReturnType = new TypeToken<EntityType>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveEntityTypes */
	private com.squareup.okhttp.Call retrieveEntityTypesCall(Double limit, Double offset, String options,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/types/".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (limit != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
		if (offset != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * If the &#x60;values&#x60; option is not in use, this operation returns a
	 * JSON array with the entity types. Each element is a JSON object with
	 * information about the type: * &#x60;type&#x60; : the entity type name. *
	 * &#x60;attrs&#x60; : the set of attribute names along with all the
	 * entities of such type, represented in a JSON object whose keys are the
	 * attribute names and whose values contain information of such attributes
	 * (in particular a list of the types used by attributes with that name
	 * along with all the entities). * &#x60;count&#x60; : the number of
	 * entities belonging to that type. If the &#x60;values&#x60; option is
	 * used, the operation returns a JSON array with a list of entity type names
	 * as strings. Results are ordered by entity &#x60;type&#x60; in
	 * alphabetical order. Response code: * Successful operation uses 200 OK *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @return List&lt;EntityType&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<EntityType> retrieveEntityTypes(Double limit, Double offset, String options) throws ApiException {
		ApiResponse<List<EntityType>> resp = retrieveEntityTypesWithHttpInfo(limit, offset, options);
		return resp.getData();
	}

	/**
	 * 
	 * If the &#x60;values&#x60; option is not in use, this operation returns a
	 * JSON array with the entity types. Each element is a JSON object with
	 * information about the type: * &#x60;type&#x60; : the entity type name. *
	 * &#x60;attrs&#x60; : the set of attribute names along with all the
	 * entities of such type, represented in a JSON object whose keys are the
	 * attribute names and whose values contain information of such attributes
	 * (in particular a list of the types used by attributes with that name
	 * along with all the entities). * &#x60;count&#x60; : the number of
	 * entities belonging to that type. If the &#x60;values&#x60; option is
	 * used, the operation returns a JSON array with a list of entity type names
	 * as strings. Results are ordered by entity &#x60;type&#x60; in
	 * alphabetical order. Response code: * Successful operation uses 200 OK *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @return ApiResponse&lt;List&lt;EntityType&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<EntityType>> retrieveEntityTypesWithHttpInfo(Double limit, Double offset, String options)
			throws ApiException {
		com.squareup.okhttp.Call call = retrieveEntityTypesCall(limit, offset, options, null, null);
		Type localVarReturnType = new TypeToken<List<EntityType>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) If the &#x60;values&#x60; option is not in use, this
	 * operation returns a JSON array with the entity types. Each element is a
	 * JSON object with information about the type: * &#x60;type&#x60; : the
	 * entity type name. * &#x60;attrs&#x60; : the set of attribute names along
	 * with all the entities of such type, represented in a JSON object whose
	 * keys are the attribute names and whose values contain information of such
	 * attributes (in particular a list of the types used by attributes with
	 * that name along with all the entities). * &#x60;count&#x60; : the number
	 * of entities belonging to that type. If the &#x60;values&#x60; option is
	 * used, the operation returns a JSON array with a list of entity type names
	 * as strings. Results are ordered by entity &#x60;type&#x60; in
	 * alphabetical order. Response code: * Successful operation uses 200 OK *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved. (optional)
	 * @param offset
	 *            Skip a number of records. (optional)
	 * @param options
	 *            Options dictionary. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveEntityTypesAsync(Double limit, Double offset, String options,
			final ApiCallback<List<EntityType>> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveEntityTypesCall(limit, offset, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<List<EntityType>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveRegistrations */
	private com.squareup.okhttp.Call retrieveRegistrationsCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/registrations".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Lists all the registrations present in the system. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @return List&lt;Registration&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<Registration> retrieveRegistrations() throws ApiException {
		ApiResponse<List<Registration>> resp = retrieveRegistrationsWithHttpInfo();
		return resp.getData();
	}

	/**
	 * 
	 * Lists all the registrations present in the system. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @return ApiResponse&lt;List&lt;Registration&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<Registration>> retrieveRegistrationsWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = retrieveRegistrationsCall(null, null);
		Type localVarReturnType = new TypeToken<List<Registration>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) Lists all the registrations present in the system.
	 * Response: * Successful operation uses 200 OK * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveRegistrationsAsync(final ApiCallback<List<Registration>> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveRegistrationsCall(progressListener, progressRequestListener);
		Type localVarReturnType = new TypeToken<List<Registration>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveSubscription */
	private com.squareup.okhttp.Call retrieveSubscriptionCall(String subscriptionId,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'subscriptionId' is set
		if (subscriptionId == null) {
			throw new ApiException(
					"Missing the required parameter 'subscriptionId' when calling retrieveSubscription(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/subscriptions/{subscriptionId}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "subscriptionId" + "\\}", apiClient.escapeString(subscriptionId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The response is the subscription represented by a JSON object as
	 * described at the beginning of this section. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @return Subscription
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public Subscription retrieveSubscription(String subscriptionId) throws ApiException {
		ApiResponse<Subscription> resp = retrieveSubscriptionWithHttpInfo(subscriptionId);
		return resp.getData();
	}

	/**
	 * 
	 * The response is the subscription represented by a JSON object as
	 * described at the beginning of this section. Response: * Successful
	 * operation uses 200 OK * Errors use a non-2xx and (optionally) an error
	 * payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @return ApiResponse&lt;Subscription&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Subscription> retrieveSubscriptionWithHttpInfo(String subscriptionId) throws ApiException {
		com.squareup.okhttp.Call call = retrieveSubscriptionCall(subscriptionId, null, null);
		Type localVarReturnType = new TypeToken<Subscription>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) The response is the subscription represented by a JSON
	 * object as described at the beginning of this section. Response: *
	 * Successful operation uses 200 OK * Errors use a non-2xx and (optionally)
	 * an error payload. See subsection on \&quot;Error Responses\&quot; for
	 * more details.
	 * 
	 * @param subscriptionId
	 *            subscription Id. (required)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveSubscriptionAsync(String subscriptionId,
			final ApiCallback<Subscription> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveSubscriptionCall(subscriptionId, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<Subscription>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for retrieveSubscriptions */
	private com.squareup.okhttp.Call retrieveSubscriptionsCall(Double limit, Double offset, String options,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/subscriptions".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (limit != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
		if (offset != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * Returns a list of all the subscriptions present in the system. Response:
	 * * Successful operation uses 200 OK * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved (optional)
	 * @param offset
	 *            Skip a number of records (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return List&lt;Subscription&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public List<Subscription> retrieveSubscriptions(Double limit, Double offset, String options) throws ApiException {
		ApiResponse<List<Subscription>> resp = retrieveSubscriptionsWithHttpInfo(limit, offset, options);
		return resp.getData();
	}

	/**
	 * 
	 * Returns a list of all the subscriptions present in the system. Response:
	 * * Successful operation uses 200 OK * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved (optional)
	 * @param offset
	 *            Skip a number of records (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;List&lt;Subscription&gt;&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<List<Subscription>> retrieveSubscriptionsWithHttpInfo(Double limit, Double offset,
			String options) throws ApiException {
		com.squareup.okhttp.Call call = retrieveSubscriptionsCall(limit, offset, options, null, null);
		Type localVarReturnType = new TypeToken<List<Subscription>>() {
		}.getType();
		return apiClient.execute(call, localVarReturnType);
	}

	/**
	 * (asynchronously) Returns a list of all the subscriptions present in the
	 * system. Response: * Successful operation uses 200 OK * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param limit
	 *            Limit the number of types to be retrieved (optional)
	 * @param offset
	 *            Skip a number of records (optional)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call retrieveSubscriptionsAsync(Double limit, Double offset, String options,
			final ApiCallback<List<Subscription>> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = retrieveSubscriptionsCall(limit, offset, options, progressListener,
				progressRequestListener);
		Type localVarReturnType = new TypeToken<List<Subscription>>() {
		}.getType();
		apiClient.executeAsync(call, localVarReturnType, callback);
		return call;
	}

	/* Build call for update */
	private com.squareup.okhttp.Call updateCall(UpdateRequest body, String options,
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling update(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/op/update".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * This operation allows to create, update and/or delete several entities in
	 * a single batch operation. The payload is an object with two properties: +
	 * &#x60;actionType&#x60;, to specify the kind of update action to do:
	 * either APPEND, APPEND_STRICT, UPDATE, DELETE. + &#x60;entities&#x60;, an
	 * array of entities, each one specified using the JSON entity
	 * representation format (described in the section \&quot;JSON Entity
	 * Representation\&quot;). Response: * Successful operation uses 204 No
	 * Content. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void update(UpdateRequest body, String options) throws ApiException {
		updateWithHttpInfo(body, options);
	}

	/**
	 * 
	 * This operation allows to create, update and/or delete several entities in
	 * a single batch operation. The payload is an object with two properties: +
	 * &#x60;actionType&#x60;, to specify the kind of update action to do:
	 * either APPEND, APPEND_STRICT, UPDATE, DELETE. + &#x60;entities&#x60;, an
	 * array of entities, each one specified using the JSON entity
	 * representation format (described in the section \&quot;JSON Entity
	 * Representation\&quot;). Response: * Successful operation uses 204 No
	 * Content. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateWithHttpInfo(UpdateRequest body, String options) throws ApiException {
		com.squareup.okhttp.Call call = updateCall(body, options, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) This operation allows to create, update and/or delete
	 * several entities in a single batch operation. The payload is an object
	 * with two properties: + &#x60;actionType&#x60;, to specify the kind of
	 * update action to do: either APPEND, APPEND_STRICT, UPDATE, DELETE. +
	 * &#x60;entities&#x60;, an array of entities, each one specified using the
	 * JSON entity representation format (described in the section \&quot;JSON
	 * Entity Representation\&quot;). Response: * Successful operation uses 204
	 * No Content. * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param body
	 *            (required)
	 * @param options
	 *            Options dictionary (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateAsync(UpdateRequest body, String options, final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateCall(body, options, progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for updateAttributeData */
	private com.squareup.okhttp.Call updateAttributeDataCall(String entityId, String attrName, Attribute body,
			String type, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException("Missing the required parameter 'entityId' when calling updateAttributeData(Async)");
		}

		// verify the required parameter 'attrName' is set
		if (attrName == null) {
			throw new ApiException("Missing the required parameter 'attrName' when calling updateAttributeData(Async)");
		}

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException("Missing the required parameter 'body' when calling updateAttributeData(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs/{attrName}".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()))
				.replaceAll("\\{" + "attrName" + "\\}", apiClient.escapeString(attrName.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The request payload is an object representing the new attribute data.
	 * Previous attribute data is replaced by the one in the request. The object
	 * follows the JSON representation for attributes (described in \&quot;JSON
	 * Attribute Representation\&quot; section). Response: * Successful
	 * operation uses 204 No Content * Errors use a non-2xx and (optionally) an
	 * error payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param entityId
	 *            Id of the entity to update (required)
	 * @param attrName
	 *            Attribute name (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void updateAttributeData(String entityId, String attrName, Attribute body, String type) throws ApiException {
		updateAttributeDataWithHttpInfo(entityId, attrName, body, type);
	}

	/**
	 * 
	 * The request payload is an object representing the new attribute data.
	 * Previous attribute data is replaced by the one in the request. The object
	 * follows the JSON representation for attributes (described in \&quot;JSON
	 * Attribute Representation\&quot; section). Response: * Successful
	 * operation uses 204 No Content * Errors use a non-2xx and (optionally) an
	 * error payload. See subsection on \&quot;Error Responses\&quot; for more
	 * details.
	 * 
	 * @param entityId
	 *            Id of the entity to update (required)
	 * @param attrName
	 *            Attribute name (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateAttributeDataWithHttpInfo(String entityId, String attrName, Attribute body,
			String type) throws ApiException {
		com.squareup.okhttp.Call call = updateAttributeDataCall(entityId, attrName, body, type, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) The request payload is an object representing the new
	 * attribute data. Previous attribute data is replaced by the one in the
	 * request. The object follows the JSON representation for attributes
	 * (described in \&quot;JSON Attribute Representation\&quot; section).
	 * Response: * Successful operation uses 204 No Content * Errors use a
	 * non-2xx and (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity to update (required)
	 * @param attrName
	 *            Attribute name (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateAttributeDataAsync(String entityId, String attrName, Attribute body,
			String type, final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateAttributeDataCall(entityId, attrName, body, type, progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for updateContextAvailabilitySubscription */
	private com.squareup.okhttp.Call updateContextAvailabilitySubscriptionCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/updateContextAvailabilitySubscription".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void updateContextAvailabilitySubscription() throws ApiException {
		updateContextAvailabilitySubscriptionWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed as POJ RPC, but we need to define a RESTful operation for
	 * this, analogous to the NGSI10 one)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateContextAvailabilitySubscriptionWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = updateContextAvailabilitySubscriptionCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed as POJ RPC, but we need to define a RESTful
	 * operation for this, analogous to the NGSI10 one)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateContextAvailabilitySubscriptionAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateContextAvailabilitySubscriptionCall(progressListener,
				progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for updateContextSubscription */
	private com.squareup.okhttp.Call updateContextSubscriptionCall(
			final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = null;

		// create path and map variables
		String localVarPath = "/v2/updateContextSubscription".replaceAll("\\{format\\}", "json");

		List<Pair> localVarQueryParams = new ArrayList<Pair>();

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful PATCH /v2/subscriptions
	 * operation)
	 * 
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void updateContextSubscription() throws ApiException {
		updateContextSubscriptionWithHttpInfo();
	}

	/**
	 * 
	 * (Not needed, as it is covered by the RESTful PATCH /v2/subscriptions
	 * operation)
	 * 
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateContextSubscriptionWithHttpInfo() throws ApiException {
		com.squareup.okhttp.Call call = updateContextSubscriptionCall(null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) (Not needed, as it is covered by the RESTful PATCH
	 * /v2/subscriptions operation)
	 * 
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateContextSubscriptionAsync(final ApiCallback<Void> callback)
			throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateContextSubscriptionCall(progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for updateOrAppendEntityAttributes */
	private com.squareup.okhttp.Call updateOrAppendEntityAttributesCall(String entityId, Attributes body, String type,
			String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException(
					"Missing the required parameter 'entityId' when calling updateOrAppendEntityAttributes(Async)");
		}

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException(
					"Missing the required parameter 'body' when calling updateOrAppendEntityAttributes(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The request payload is an object representing the attributes to append or
	 * update. The object follows the JSON entity representation format
	 * (described in \&quot;JSON Entity Representation\&quot; section), except
	 * that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity
	 * attributes are updated with the ones in the payload, depending on whether
	 * the &#x60;append&#x60; operation option is used or not. * If
	 * &#x60;append&#x60; is not used: the entity attributes are updated (if
	 * they previously exist) or appended (if they don&#39;t previously exist)
	 * with the ones in the payload. * If &#x60;append&#x60; is used (i.e.
	 * strict append semantics): all the attributes in the payload not
	 * previously existing in the entity are appended. In addition to that, in
	 * case some of the attributes in the payload already exist in the entity,
	 * an error is returned. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Entity id to be updated (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void updateOrAppendEntityAttributes(String entityId, Attributes body, String type, String options)
			throws ApiException {
		updateOrAppendEntityAttributesWithHttpInfo(entityId, body, type, options);
	}

	/**
	 * 
	 * The request payload is an object representing the attributes to append or
	 * update. The object follows the JSON entity representation format
	 * (described in \&quot;JSON Entity Representation\&quot; section), except
	 * that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity
	 * attributes are updated with the ones in the payload, depending on whether
	 * the &#x60;append&#x60; operation option is used or not. * If
	 * &#x60;append&#x60; is not used: the entity attributes are updated (if
	 * they previously exist) or appended (if they don&#39;t previously exist)
	 * with the ones in the payload. * If &#x60;append&#x60; is used (i.e.
	 * strict append semantics): all the attributes in the payload not
	 * previously existing in the entity are appended. In addition to that, in
	 * case some of the attributes in the payload already exist in the entity,
	 * an error is returned. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Entity id to be updated (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateOrAppendEntityAttributesWithHttpInfo(String entityId, Attributes body, String type,
			String options) throws ApiException {
		com.squareup.okhttp.Call call = updateOrAppendEntityAttributesCall(entityId, body, type, options, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) The request payload is an object representing the
	 * attributes to append or update. The object follows the JSON entity
	 * representation format (described in \&quot;JSON Entity
	 * Representation\&quot; section), except that &#x60;id&#x60; and
	 * &#x60;type&#x60; are not allowed. The entity attributes are updated with
	 * the ones in the payload, depending on whether the &#x60;append&#x60;
	 * operation option is used or not. * If &#x60;append&#x60; is not used: the
	 * entity attributes are updated (if they previously exist) or appended (if
	 * they don&#39;t previously exist) with the ones in the payload. * If
	 * &#x60;append&#x60; is used (i.e. strict append semantics): all the
	 * attributes in the payload not previously existing in the entity are
	 * appended. In addition to that, in case some of the attributes in the
	 * payload already exist in the entity, an error is returned. Response: *
	 * Successful operation uses 204 No Content * Errors use a non-2xx and
	 * (optionally) an error payload. See subsection on \&quot;Error
	 * Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Entity id to be updated (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateOrAppendEntityAttributesAsync(String entityId, Attributes body, String type,
			String options, final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateOrAppendEntityAttributesCall(entityId, body, type, options,
				progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}

	/* Build call for updateReplaceAllEntityAttributes */
	private com.squareup.okhttp.Call updateReplaceAllEntityAttributesCall(String entityId, Attributes body, String type,
			String options, final ProgressResponseBody.ProgressListener progressListener,
			final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
		Object localVarPostBody = body;

		// verify the required parameter 'entityId' is set
		if (entityId == null) {
			throw new ApiException(
					"Missing the required parameter 'entityId' when calling updateReplaceAllEntityAttributes(Async)");
		}

		// verify the required parameter 'body' is set
		if (body == null) {
			throw new ApiException(
					"Missing the required parameter 'body' when calling updateReplaceAllEntityAttributes(Async)");
		}

		// create path and map variables
		String localVarPath = "/v2/entities/{entityId}/attrs".replaceAll("\\{format\\}", "json")
				.replaceAll("\\{" + "entityId" + "\\}", apiClient.escapeString(entityId.toString()));

		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		if (type != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
		if (options != null)
			localVarQueryParams.addAll(apiClient.parameterToPairs("", "options", options));

		Map<String, String> localVarHeaderParams = new HashMap<String, String>();

		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
		if (localVarAccept != null)
			localVarHeaderParams.put("Accept", localVarAccept);

		final String[] localVarContentTypes = {

		};
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
		if (localVarContentType != null)
			localVarHeaderParams.put("Content-Type", localVarContentType);

		if (progressListener != null) {
			apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
				@Override
				public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain)
						throws IOException {
					com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
					return originalResponse.newBuilder()
							.body(new ProgressResponseBody(originalResponse.body(), progressListener)).build();
				}
			});
		}

		String[] localVarAuthNames = new String[] {};
		return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarPostBody, localVarHeaderParams,
				localVarFormParams, localVarAuthNames, progressRequestListener);
	}

	/**
	 * 
	 * The request payload is an object representing the new entity attributes.
	 * The object follows the JSON entity representation format (described in a
	 * \&quot;JSON Entity Representation\&quot; above), except that
	 * &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes
	 * previously existing in the entity are removed and replaced by the ones in
	 * the request. Response: * Successful operation uses 204 No Content *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question. (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public void updateReplaceAllEntityAttributes(String entityId, Attributes body, String type, String options)
			throws ApiException {
		updateReplaceAllEntityAttributesWithHttpInfo(entityId, body, type, options);
	}

	/**
	 * 
	 * The request payload is an object representing the new entity attributes.
	 * The object follows the JSON entity representation format (described in a
	 * \&quot;JSON Entity Representation\&quot; above), except that
	 * &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes
	 * previously existing in the entity are removed and replaced by the ones in
	 * the request. Response: * Successful operation uses 204 No Content *
	 * Errors use a non-2xx and (optionally) an error payload. See subsection on
	 * \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question. (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @return ApiResponse&lt;Void&gt;
	 * @throws ApiException
	 *             If fail to call the API, e.g. server error or cannot
	 *             deserialize the response body
	 */
	public ApiResponse<Void> updateReplaceAllEntityAttributesWithHttpInfo(String entityId, Attributes body, String type,
			String options) throws ApiException {
		com.squareup.okhttp.Call call = updateReplaceAllEntityAttributesCall(entityId, body, type, options, null, null);
		return apiClient.execute(call);
	}

	/**
	 * (asynchronously) The request payload is an object representing the new
	 * entity attributes. The object follows the JSON entity representation
	 * format (described in a \&quot;JSON Entity Representation\&quot; above),
	 * except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The
	 * attributes previously existing in the entity are removed and replaced by
	 * the ones in the request. Response: * Successful operation uses 204 No
	 * Content * Errors use a non-2xx and (optionally) an error payload. See
	 * subsection on \&quot;Error Responses\&quot; for more details.
	 * 
	 * @param entityId
	 *            Id of the entity in question. (required)
	 * @param body
	 *            (required)
	 * @param type
	 *            Entity type, to avoid ambiguity in the case there are several
	 *            entities with the same entity id. (optional)
	 * @param options
	 *            Operations options (optional)
	 * @param callback
	 *            The callback to be executed when the API call finishes
	 * @return The request call
	 * @throws ApiException
	 *             If fail to process the API call, e.g. serializing the request
	 *             body object
	 */
	public com.squareup.okhttp.Call updateReplaceAllEntityAttributesAsync(String entityId, Attributes body, String type,
			String options, final ApiCallback<Void> callback) throws ApiException {

		ProgressResponseBody.ProgressListener progressListener = null;
		ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

		if (callback != null) {
			progressListener = new ProgressResponseBody.ProgressListener() {
				@Override
				public void update(long bytesRead, long contentLength, boolean done) {
					callback.onDownloadProgress(bytesRead, contentLength, done);
				}
			};

			progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
				@Override
				public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
					callback.onUploadProgress(bytesWritten, contentLength, done);
				}
			};
		}

		com.squareup.okhttp.Call call = updateReplaceAllEntityAttributesCall(entityId, body, type, options,
				progressListener, progressRequestListener);
		apiClient.executeAsync(call, callback);
		return call;
	}
}
